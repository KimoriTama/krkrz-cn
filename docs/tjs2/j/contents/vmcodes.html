<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html  xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh" lang="zh">
<!-- generated by to_html.pl from vmcodes.xml -->
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
	<title>虚拟机</title>
	<meta name="author" content="W.Dee" />
	<meta http-equiv="Content-Style-Type" content="text/css" />
	<meta http-equiv="Content-Script-Type" content="text/javascript" />
	<link href="browser.css" type="text/css" rel="stylesheet" title="吉里吉里相关标准参考样式" />
	<link href="mailto:dee@kikyou.info" rev="Made" />
	<link href="index.html" target="_top" rel="Start" title="首页" />
</head>
<body>
<h1><a id="id462" name="id462">TJS2 VM</a>
</h1><div class="para"><div>
　TJS2会先将脚本编译为虚拟机 (TJS2 <a id="id463" name="id463" class="targanchor"><dfn>VM</dfn></a>) 用的二进制代码，然后再执行。。<br />
　当程序出现异常或转储(dump)时，将显示 TJS2 VM 代码的反汇编结果，因此这里将简要介绍一下该虚拟机。<br />
</div></div>
<h1><a id="id464" name="id464">指令码</a>
</h1><div class="para"><div>
　在TJS2 VM 中每个执行单元（如函数和属性）都是独立的，一个函数不会与另一个函数共享指令码空间、寄存器空间、标志(flag)或常量空间。<br />
　指令指针 (ip) 一定是从0开始，例如函数的开头。<br />
　这些指令码是用人类简单易读的助记符(mnemonic)命名的。</div></div>
<h1><a id="id465" name="id465">寄存器</a>
</h1><div class="para"><div>
　TJS2 VM 的寄存器在助记符中以 %(数字) 的形式表示。这里的数字可以是负数。寄存器的数量是不限的。所有局部变量和计算中的临时值都会记录在寄存器中。没有主存 (main memory) 或堆栈。<br />
　寄存器表示的值与 TJS2 中所谓的变量相同，可以表示整数、实数、对象、字符串、字节串、void。<br />
　在当前版本中，寄存器 %0 始终为 void。寄存器 %-1 为 this。寄存器 %-2 是一个叫做 <a id="id466" name="id466" class="targanchor"><dfn>this proxy</dfn></a> 的特殊对象，对该对象执行成员引用时，首先会查看 this 对象、如果找不到则会查看 global 对象。this proxy 在 global 级别的执行单元中并不存在。函数等参数将以预先存储在 %-3 或 %-4 等寄存器中的状态下开始执行。<br />
　【译者注：通常在脚本内的global全局变量和最外层的this变量会优先使用%-1 和 %-2 寄存器，不够用了才向后沿用，而其中的函数方法、语句块、with一类含有内置(局部)变量和表达式的部分可能会经常优先用到 %-3 或 %-4 等往后的寄存器。】<br />
　除了像这种预先确定了用途、或在执行前预先包含数值的寄存器以外的数值，在代码执行开始时是不确定的。<br />
</div></div>
<h1><a id="id467" name="id467">标志(flag)</a>
</h1><div class="para"><div>
　TJS2 VM 只有1个标志，用于存储比较结果。标志只接受真值或假值。<br />
</div></div>
<h1><a id="id468" name="id468">常量区域</a>
</h1><div class="para"><div>
　TJS2 VM 的常量区域是存储常量的地方，在助记符中用 *(数字) 表示。常量区域是只读的，使用 const 指令可将该常量区域的值转移到寄存器中。此外，用于通过名称访问对象成员的「对象命名」（例如函数名和属性名）也存储在此常量区域中。<br />
</div></div>
<h1><a id="id469" name="id469">VM 助记符一览</a>
</h1><div class="para"><div>
　一些操作数格式为 <code class="inlinecode">%obj.*name</code> 或 <code class="inlinecode">%obj.%name</code> ，但它们都涉及对象成员的引用。<br />
　格式为 <code class="inlinecode">%obj.*name</code> 的操作数进行直接引用，以寄存器 <code class="inlinecode">%obj</code> 表示的对象引用以 <code class="inlinecode">*name</code> 名称表示的直接成员。<br />
　格式为 <code class="inlinecode">%obj.%name</code> 的操作数进行间接引用，以寄存器 <code class="inlinecode">%obj</code> 表示的对象引用以 <code class="inlinecode">%name</code> 名称表示的间接成员。<br />
　这些指令的助记符是以 d 亦或 pd (direct / property direct) 或者 i 亦或 pi (indirect / property indirect) 为后缀。<br />
　后缀带有 p 的指令、将操作目标寄存器的属性控制器 (执行单项 '*' 操作符)。<br />
<br />
<br />
<dl>
<dt><a id="id470" name="id470" class="targanchor"><dfn>nop</dfn></a><br />
(no operation)</dt>
<dd>　什么操作都不做。</dd>

<dt><a id="id471" name="id471" class="targanchor"><dfn>const</dfn></a><br />
(copy constant value)</dt>
<dd>格式: <code class="inlinecode">const %dest, *src</code><br />
<br />
　将 *src 中表示的常量区域的值复制到 %dest 表示的寄存器中。</dd>

<dt><a id="id472" name="id472" class="targanchor"><dfn>cp</dfn></a><br />
(copy register)</dt>
<dd>格式: <code class="inlinecode">cp %dest, %src</code><br />
<br />
　将 %src 表示的寄存器的值复制到 %dest 表示的寄存器中。</dd>

<dt><a id="id473" name="id473" class="targanchor"><dfn>cl</dfn></a><br />
(clear register)</dt>
<dd>格式: <code class="inlinecode">cl %dest</code><br />
<br />
　将 %dest 表示的寄存器设置为 void。</dd>

<dt><a id="id474" name="id474" class="targanchor"><dfn>ccl</dfn></a><br />
(clear register)</dt>
<dd>格式: <code class="inlinecode">ccl %low-%high</code><br />
<br />
　把所有范围从以 %low 表示的寄存器到以 %high 表示的寄存器设置为 void。</dd>

<dt><a id="id475" name="id475" class="targanchor"><dfn>tt</dfn></a><br />
(test true)</dt>
<dd>格式: <code class="inlinecode">tt %reg</code><br />
<br />
　如果 %reg 所示的寄存器表示真，则将标志设为真，如果表示假则将标志设为假。</dd>

<dt><a id="id476" name="id476" class="targanchor"><dfn>tf</dfn></a><br />
(test false)</dt>
<dd>格式: <code class="inlinecode">tf %reg</code><br />
<br />
　与 tt 相反，如果 %reg 所示的寄存器表示真，则将标志设为假；如果表示假则将标志设为真。</dd>

<dt><a id="id477" name="id477" class="targanchor"><dfn>ceq</dfn></a><br />
(compare equal)</dt>
<dd>格式: <code class="inlinecode">ceq %reg1, %reg2</code><br />
<br />
　如果 %reg1 和 %reg2 进行通常比较 ( == 运算符行为 ) 中结果一致，则标志设为真，否则设定为假。</dd>

<dt><a id="id478" name="id478" class="targanchor"><dfn>cdeq</dfn></a><br />
(compare distinct equal)</dt>
<dd>格式: <code class="inlinecode">cdeq %reg1, %reg2</code><br />
<br />
　如果 %reg1 和 %reg2 在类型识别比较 ( === 运算符行为 ) 中结果一致则将标志设置为真，否则设置为假。</dd>

<dt><a id="id479" name="id479" class="targanchor"><dfn>clt</dfn></a><br />
(compare littler than)</dt>
<dd>格式: <code class="inlinecode">clt %reg1, %reg2</code><br />
<br />
　如果是 %reg1 &lt; %reg2 则将标志设置为真，否则将标志设置为假。</dd>

<dt><a id="id480" name="id480" class="targanchor"><dfn>cgt</dfn></a><br />
(compare greater than)</dt>
<dd>格式: <code class="inlinecode">cgt %reg1, %reg2</code><br />
<br />
　如果是 %reg1 &gt; %reg2 则将标志设置为真，否则将标志设置为假。</dd>

<dt><a id="id481" name="id481" class="targanchor"><dfn>setf</dfn></a><br />
(set flag)</dt>
<dd>格式: <code class="inlinecode">setf %dest</code><br />
<br />
　如果标志为真，则将 %dest 设置为真 (整数非0) ，如果标志为假则设置为假 (整数0)。</dd>

<dt><a id="id482" name="id482" class="targanchor"><dfn>setnf</dfn></a><br />
(set not flag)</dt>
<dd>格式: <code class="inlinecode">setnf %dest</code><br />
<br />
　与 setf 相反，如果标志为假，则将 %dest 设置为真 (整数非0) ，如果标志为真则设置为假 (整数0)。</dd>

<dt><a id="id483" name="id483" class="targanchor"><dfn>lnot</dfn></a><br />
(logical not)</dt>
<dd>格式: <code class="inlinecode">lnot %reg</code><br />
<br />
　将 %reg 的真假颠倒。</dd>

<dt><a id="id484" name="id484" class="targanchor"><dfn>nf</dfn></a><br />
(not flag)</dt>
<dd>格式: <code class="inlinecode">nf</code><br />
<br />
　将标志的真假颠倒。</dd>

<dt><a id="id485" name="id485" class="targanchor"><dfn>jf</dfn></a><br />
(jump if flag)</dt>
<dd>格式: <code class="inlinecode">jf ip</code><br />
<br />
　如果标志为真则跳转到 ip 。</dd>

<dt><a id="id486" name="id486" class="targanchor"><dfn>jnf</dfn></a><br />
(jump if not flag)</dt>
<dd>格式: <code class="inlinecode">jnf ip</code><br />
<br />
　如果标志为假则跳转到 ip 。</dd>

<dt><a id="id487" name="id487" class="targanchor"><dfn>inc</dfn></a>, <a id="id488" name="id488" class="targanchor"><dfn>incpd</dfn></a>, <a id="id489" name="id489" class="targanchor"><dfn>incpi</dfn></a>, <a id="id490" name="id490" class="targanchor"><dfn>incp</dfn></a><br />
(increment)</dt>
<dd>格式: <code class="inlinecode">inc %reg</code><br />
格式: <code class="inlinecode">incpd %res, %obj.*name</code><br />
格式: <code class="inlinecode">incpi %res, %obj.%name</code><br />
格式: <code class="inlinecode">incp %res, %propobj</code><br />
<br />
　对 %reg 或 %obj.*name 或 %obj.%name 或 %propobj 进行递增运算。<br />
　在上述格式的指令中，如果参数中有 %res、且 res 不为 0 时，结果也会存储在 %res 中。<br />
</dd>

<dt><a id="id491" name="id491" class="targanchor"><dfn>dec</dfn></a>, <a id="id492" name="id492" class="targanchor"><dfn>decpd</dfn></a>, <a id="id493" name="id493" class="targanchor"><dfn>decpi</dfn></a>, <a id="id494" name="id494" class="targanchor"><dfn>decp</dfn></a><br />
(decrement)</dt>
<dd>格式: <code class="inlinecode">dec %reg</code><br />
格式: <code class="inlinecode">decpd %res, %obj.*name</code><br />
格式: <code class="inlinecode">decpi %res, %obj.%name</code><br />
格式: <code class="inlinecode">decp %res, %propobj</code><br />
<br />
　对 %reg 或 %obj.*name 或 %obj.%name 或 %propobj 进行递减运算。<br />
　在上述格式的指令中，如果参数中有 %res 、且 res 不为 0 时，结果也会存储在 %res 中。<br />
</dd>

<dt><a id="id495" name="id495" class="targanchor"><dfn>lor</dfn></a>, <a id="id496" name="id496" class="targanchor"><dfn>lorpd</dfn></a>, <a id="id497" name="id497" class="targanchor"><dfn>lorpi</dfn></a>, <a id="id498" name="id498" class="targanchor"><dfn>lorp</dfn></a><br />
(logical or)</dt>
<dd>格式: <code class="inlinecode">lor %dest, %src</code><br />
<br />
　计算 %dest 和 %src 的逻辑和（逻辑或），并将结果存储在 %dest 中。<br />
<br />
格式: <code class="inlinecode">lorpd %res, %obj.*name, %src</code><br />
<br />
　计算 %obj.*name 和 %src  的逻辑和（逻辑或），并将结果存储在 %obj.*name 中。<br />
<br />
格式: <code class="inlinecode">lorpi %res, %obj.%name, %src</code><br />
<br />
　计算 %obj.%name 和 %src 的逻辑和（逻辑或），并将结果存储在 %obj.%name 中。<br />
<br />
格式: <code class="inlinecode">lorp %res, %propobj, %src</code><br />
<br />
　计算 %propobj 和 %src 的逻辑和（逻辑或），并将结果存储在 %propobj 中。<br />
<br />
　在上面的指令中，如果参数中有 %res ，并且 res 不是 0 、则结果也会存储在 %res 中。<br />
</dd>

<dt><a id="id499" name="id499" class="targanchor"><dfn>land</dfn></a>, <a id="id500" name="id500" class="targanchor"><dfn>landpd</dfn></a>, <a id="id501" name="id501" class="targanchor"><dfn>landpi</dfn></a>, <a id="id502" name="id502" class="targanchor"><dfn>landp</dfn></a><br />
(logical and)</dt>
<dd>格式: <code class="inlinecode">land %dest, %src</code><br />
<br />
　计算 %dest 和 %src 的逻辑乘（逻辑与），并将结果存储在 %dest 中。<br />
<br />
格式: <code class="inlinecode">landpd %res, %obj.*name, %src</code><br />
<br />
　计算 %obj.*name 和 %src 的逻辑乘（逻辑与），并将结果存储在 %obj.*name 中。<br />
<br />
格式: <code class="inlinecode">landpi %res, %obj.%name, %src</code><br />
<br />
　计算 %obj.%name 和 %src 的逻辑乘（逻辑与），并将结果存储在 %obj.%name 中。<br />
<br />
格式: <code class="inlinecode">landp %res, %propobj, %src</code><br />
<br />
　计算 %propobj 和 %src 的逻辑乘（逻辑与），并将结果存储在 %propobj 中。<br />
<br />
　在上面的指令中，如果参数中有 %res ，并且 res 不是 0 、则结果也会存储在 %res 中。<br />
</dd>

<dt><a id="id503" name="id503" class="targanchor"><dfn>bor</dfn></a>, <a id="id504" name="id504" class="targanchor"><dfn>borpd</dfn></a>, <a id="id505" name="id505" class="targanchor"><dfn>borpi</dfn></a>, <a id="id506" name="id506" class="targanchor"><dfn>borp</dfn></a><br />
(bitwise or)</dt>
<dd>格式: <code class="inlinecode">bor %dest, %src</code><br />
<br />
　计算 %dest 和 %src 每个位的逻辑和（逻辑或），并将结果存储在 %dest 中。<br />
<br />
格式: <code class="inlinecode">borpd %res, %obj.*name, %src</code><br />
<br />
　计算 %obj.*name 和 %src 每个位的逻辑和（逻辑或），并将结果存储在 %obj.*name 中。<br />
<br />
格式: <code class="inlinecode">borpi %res, %obj.%name, %src</code><br />
<br />
　计算 %obj.%name 和 %src 每个位的逻辑和（逻辑或），并将结果存储在 %obj.%name 中。<br />
<br />
格式: <code class="inlinecode">borp %res, %propobj, %src</code><br />
<br />
　计算 %propobj 和 %src 每个位的逻辑和（逻辑或），并将结果存储在 %propobj 中。<br />
<br />
　在上面的指令中，如果参数中有 %res ，并且 res 不是 0 、则结果也会存储在 %res 中。<br />
</dd>

<dt><a id="id507" name="id507" class="targanchor"><dfn>bxor</dfn></a>, <a id="id508" name="id508" class="targanchor"><dfn>bxorpd</dfn></a>, <a id="id509" name="id509" class="targanchor"><dfn>bxorpi</dfn></a>, <a id="id510" name="id510" class="targanchor"><dfn>bxorp</dfn></a><br />
(bitwise xor)</dt>
<dd>格式: <code class="inlinecode">bxor %dest, %src</code><br />
<br />
　计算 %dest 和 %src 每个位的逻辑异或，并将结果存储在 %dest 中。<br />
<br />
格式: <code class="inlinecode">bxorpd %res, %obj.*name, %src</code><br />
<br />
　计算 %obj.*name 和 %src 每个位的逻辑异或，并将结果存储在 %obj.*name 中。<br />
<br />
格式: <code class="inlinecode">bxorpi %res, %obj.%name, %src</code><br />
<br />
　计算 %obj.%name 和 %src 每个位的逻辑异或，并将结果存储在 %obj.%name 中。<br />
<br />
格式: <code class="inlinecode">bxorp %res, %propobj, %src</code><br />
<br />
　计算 %propobj 和 %src 每个位的逻辑异或，并将结果存储在 %propobj 中。<br />
<br />
　在上面的指令中，如果参数中有 %res ，并且 res 不是 0 、则结果也会存储在 %res 中。<br />
</dd>

<dt><a id="id511" name="id511" class="targanchor"><dfn>band</dfn></a>, <a id="id512" name="id512" class="targanchor"><dfn>bandpd</dfn></a>, <a id="id513" name="id513" class="targanchor"><dfn>bandpi</dfn></a>, <a id="id514" name="id514" class="targanchor"><dfn>bandp</dfn></a><br />
(bitwise and)</dt>
<dd>格式: <code class="inlinecode">band %dest, %src</code><br />
<br />
　计算 %dest 和 %src 每个位的逻辑乘（逻辑与），并将结果存储在 %dest 中。<br />
<br />
格式: <code class="inlinecode">bandpd %res, %obj.*name, %src</code><br />
<br />
　计算 %obj.*name 和 %src 每个位的逻辑乘（逻辑与），并将结果存储在 %obj.*name 中。<br />
<br />
格式: <code class="inlinecode">bandpi %res, %obj.%name, %src</code><br />
<br />
　计算 %obj.%name 和 %src 每个位的逻辑乘（逻辑与），并将结果存储在 %obj.%name 中。<br />
<br />
格式: <code class="inlinecode">bandp %res, %propobj, %src</code><br />
<br />
　计算 %propobj 和 %src 每个位的逻辑乘（逻辑与），并将结果存储在 %propobj 中。<br />
<br />
　在上面的指令中，如果参数中有 %res ，并且 res 不是 0 、则结果也会存储在 %res 中。<br />
</dd>

<dt><a id="id515" name="id515" class="targanchor"><dfn>sar</dfn></a>, <a id="id516" name="id516" class="targanchor"><dfn>sarpd</dfn></a>, <a id="id517" name="id517" class="targanchor"><dfn>sarpi</dfn></a>, <a id="id518" name="id518" class="targanchor"><dfn>sarp</dfn></a><br />
(shift arithmetic right)</dt>
<dd>格式: <code class="inlinecode">sar %dest, %src</code><br />
<br />
　将 %dest 对 %src 所表示的次数进行算术右移（向右的带符号位移），其结果存储在 %dest 中。<br />
<br />
格式: <code class="inlinecode">sarpd %res, %obj.*name, %src</code><br />
<br />
　将 %obj.*name 对 %src 所表示的次数进行算术右移（向右的带符号位移），其结果存储在 %obj.*name 中。<br />
<br />
格式: <code class="inlinecode">sarpi %res, %obj.%name, %src</code><br />
<br />
　将 %obj.%name 对 %src 所表示的次数进行算术右移（向右的带符号位移），其结果存储在 %obj.%name 中。<br />
<br />
格式: <code class="inlinecode">sarp %res, %propobj, %src</code><br />
<br />
　将 %propobj 对 %src 所表示的次数进行算术右移（向右的带符号位移），其结果存储在 %propobj 中。<br />
<br />
　在上面的指令中，如果参数中有 %res ，并且 res 不是 0 、则结果也会存储在 %res 中。<br />
</dd>

<dt><a id="id519" name="id519" class="targanchor"><dfn>sal</dfn></a>, <a id="id520" name="id520" class="targanchor"><dfn>salpd</dfn></a>, <a id="id521" name="id521" class="targanchor"><dfn>salpi</dfn></a>, <a id="id522" name="id522" class="targanchor"><dfn>salp</dfn></a><br />
(shift arithmetic left)</dt>
<dd>格式: <code class="inlinecode">sal %dest, %src</code><br />
<br />
　将 %dest 对 %src 所表示的次数进行算术左移（向左的带符号位移），其结果存储在 %dest 中。<br />
<br />
格式: <code class="inlinecode">salpd %res, %obj.*name, %src</code><br />
<br />
　将 %obj.*name 对 %src 所表示的次数进行算术左移（向左的带符号位移），其结果存储在 %obj.*name 中。<br />
<br />
格式: <code class="inlinecode">salpi %res, %obj.%name, %src</code><br />
<br />
　将 %obj.%name 对 %src 所表示的次数进行算术左移（向左的带符号位移），其结果存储在 %obj.%name に格納します。<br />
<br />
格式: <code class="inlinecode">salp %res, %propobj, %src</code><br />
<br />
　将 %propobj 对 %src 所表示的次数进行算术左移（向左的带符号位移），其结果存储在 %propobj 中。<br />
<br />
　在上面的指令中，如果参数中有 %res ，并且 res 不是 0 、则结果也会存储在 %res 中。<br />
</dd>

<dt><a id="id523" name="id523" class="targanchor"><dfn>sr</dfn></a>, <a id="id524" name="id524" class="targanchor"><dfn>srpd</dfn></a>, <a id="id525" name="id525" class="targanchor"><dfn>srpi</dfn></a>, <a id="id526" name="id526" class="targanchor"><dfn>srp</dfn></a><br />
(shift bitwise right)</dt>
<dd>格式: <code class="inlinecode">sr %dest, %src</code><br />
<br />
　将 %dest 对 %src 所表示的次数进行逻辑右移（向右的无符号位移），其结果存储在 %dest 中。<br />
<br />
格式: <code class="inlinecode">srpd %res, %obj.*name, %src</code><br />
<br />
　将 %obj.*name 对 %src 所表示的次数进行逻辑右移（向右的无符号位移），其结果存储在 %obj.*name 中。<br />
<br />
格式: <code class="inlinecode">srpi %res, %obj.%name, %src</code><br />
<br />
　将 %obj.%name 对 %src 所表示的次数进行逻辑右移（向右的无符号位移），其结果存储在 %obj.%name 中。<br />
<br />
格式: <code class="inlinecode">srp %res, %propobj, %src</code><br />
<br />
　将 %propobj 对 %src 所表示的次数进行逻辑右移（向右的无符号位移），其结果存储在 %propobj 中。<br />
<br />
　在上面的指令中，如果参数中有 %res ，并且 res 不是 0 、则结果也会存储在 %res 中。<br />
</dd>

<dt><a id="id527" name="id527" class="targanchor"><dfn>add</dfn></a>, <a id="id528" name="id528" class="targanchor"><dfn>addpd</dfn></a>, <a id="id529" name="id529" class="targanchor"><dfn>addpi</dfn></a>, <a id="id530" name="id530" class="targanchor"><dfn>addp</dfn></a><br />
(add)</dt>
<dd>格式: <code class="inlinecode">add %dest, %src</code><br />
<br />
　将 %dest 与 %src 相加并将结果存储在 %dest 中。<br />
<br />
格式: <code class="inlinecode">addpd %res, %obj.*name, %src</code><br />
<br />
　将 %obj.*name 与 %src 相加并将结果存储在 %obj.*name 中。<br />
<br />
格式: <code class="inlinecode">addpi %res, %obj.%name, %src</code><br />
<br />
　将 %obj.%name 与 %src 相加并将结果存储在 %obj.%name 中。<br />
<br />
格式: <code class="inlinecode">addp %res, %propobj, %src</code><br />
<br />
　将 %propobj 与 %src 相加并将结果存储在 %propobj 中。<br />
<br />
　在上面的指令中，如果参数含有 %res 、且 res 不为0，则结果也会存储在 %res 中。<br />
</dd>

<dt><a id="id531" name="id531" class="targanchor"><dfn>sub</dfn></a>, <a id="id532" name="id532" class="targanchor"><dfn>subpd</dfn></a>, <a id="id533" name="id533" class="targanchor"><dfn>subpi</dfn></a>, <a id="id534" name="id534" class="targanchor"><dfn>subp</dfn></a><br />
(subtract)</dt>
<dd>格式: <code class="inlinecode">sub %dest, %src</code><br />
<br />
　将 %dest 减去 %src 并将结果存储在 %dest 中。<br />
<br />
格式: <code class="inlinecode">subpd %res, %obj.*name, %src</code><br />
<br />
　将 %obj.*name 减去 %src 并将结果存储在 %obj.*name 中。<br />
<br />
格式: <code class="inlinecode">subpi %res, %obj.%name, %src</code><br />
<br />
　将 %obj.%name 减去 %src 并将结果存储在 %obj.%name 中。<br />
<br />
格式: <code class="inlinecode">subp %res, %propobj, %src</code><br />
<br />
　将 %propobj 减去 %src 并将结果存储在 %propobj 中。<br />
<br />
　在上面的指令中，如果参数中有 %res ，并且 res 不是 0 、则结果也会存储在 %res 中。<br />
</dd>

<dt><a id="id535" name="id535" class="targanchor"><dfn>mod</dfn></a>, <a id="id536" name="id536" class="targanchor"><dfn>modpd</dfn></a>, <a id="id537" name="id537" class="targanchor"><dfn>modpi</dfn></a>, <a id="id538" name="id538" class="targanchor"><dfn>modp</dfn></a><br />
(modulo)</dt>
<dd>格式: <code class="inlinecode">mod %dest, %src</code><br />
<br />
　将 %dest 除以 %src 的余数存储在 %dest 中。<br />
<br />
格式: <code class="inlinecode">modpd %res, %obj.*name, %src</code><br />
<br />
　将 %obj.*name 除以 %src 的余数存储在 %obj.*name 中。<br />
<br />
格式: <code class="inlinecode">modpi %res, %obj.%name, %src</code><br />
<br />
　将 %obj.%name 除以 %src 的余数存储在 %obj.%name 中。<br />
<br />
格式: <code class="inlinecode">modp %res, %propobj, %src</code><br />
<br />
　将 %propobj 除以 %src 的余数存储在 %propobj 中。<br />
<br />
　在上面的指令中，如果参数中有 %res ，并且 res 不是 0 、则结果也会存储在 %res 中。<br />
</dd>

<dt><a id="id539" name="id539" class="targanchor"><dfn>div</dfn></a>, <a id="id540" name="id540" class="targanchor"><dfn>divpd</dfn></a>, <a id="id541" name="id541" class="targanchor"><dfn>divpi</dfn></a>, <a id="id542" name="id542" class="targanchor"><dfn>divp</dfn></a><br />
(real divide)</dt>
<dd>格式: <code class="inlinecode">div %dest, %src</code><br />
<br />
　将 %dest 以实数运算除以 %src，并将其实数结果存储在 %dest 中。<br />
<br />
格式: <code class="inlinecode">divpd %res, %obj.*name, %src</code><br />
<br />
　将 %obj.*name 以实数运算除以 %src，并将其实数结果存储在 %obj.*name 中。<br />
<br />
格式: <code class="inlinecode">divpi %res, %obj.%name, %src</code><br />
<br />
　将 %obj.%name 以实数运算除以 %src，并将其实数结果存储在 %obj.%name 中。<br />
<br />
格式: <code class="inlinecode">divp %res, %propobj, %src</code><br />
<br />
　将 %propobj 以实数运算除以 %src，并将其实数结果存储在 %propobj 中。<br />
<br />
　在上面的指令中，如果参数中有 %res ，并且 res 不是 0 、则结果也会存储在 %res 中。<br />
</dd>

<dt><a id="id543" name="id543" class="targanchor"><dfn>idiv</dfn></a>, <a id="id544" name="id544" class="targanchor"><dfn>idivpd</dfn></a>, <a id="id545" name="id545" class="targanchor"><dfn>idivpi</dfn></a>, <a id="id546" name="id546" class="targanchor"><dfn>idivp</dfn></a><br />
(integer divide)</dt>
<dd>格式: <code class="inlinecode">idiv %dest, %src</code><br />
<br />
　将 %dest 以整数运算除以 %src，并将其整数结果存储在 %dest 中。<br />
<br />
格式: <code class="inlinecode">idivpd %res, %obj.*name, %src</code><br />
<br />
　将 %obj.*name 以整数运算除以 %src，并将其整数结果存储在 %obj.*name 中。<br />
<br />
格式: <code class="inlinecode">idivpi %res, %obj.%name, %src</code><br />
<br />
　将 %obj.%name 以整数运算除以 %src，并将其整数结果存储在 %obj.%name 中。<br />
<br />
格式: <code class="inlinecode">divp %res, %propobj, %src</code><br />
<br />
　将 %propobj 以整数运算除以 %src，并将其整数结果存储在 %propobj 中。<br />
<br />
　在上面的指令中，如果参数中有 %res ，并且 res 不是 0 、则结果也会存储在 %res 中。<br />
</dd>

<dt><a id="id547" name="id547" class="targanchor"><dfn>mul</dfn></a>, <a id="id548" name="id548" class="targanchor"><dfn>mulpd</dfn></a>, <a id="id549" name="id549" class="targanchor"><dfn>mulpi</dfn></a>, <a id="id550" name="id550" class="targanchor"><dfn>mulp</dfn></a><br />
(multiply)</dt>
<dd>格式: <code class="inlinecode">mul %dest, %src</code><br />
<br />
　将 %dest 乘以 %src 并将结果存储在 %dest 中。<br />
<br />
格式: <code class="inlinecode">mulpd %res, %obj.*name, %src</code><br />
<br />
　将 %obj.*name 乘以 %src 并将结果存储在 %obj.*name 中。<br />
<br />
格式: <code class="inlinecode">mulpi %res, %obj.%name, %src</code><br />
<br />
　将 %obj.%name 乘以 %src 并将结果存储在 %obj.%name 中。<br />
<br />
格式: <code class="inlinecode">mulp %res, %propobj, %src</code><br />
<br />
　将 %propobj 乘以 %src 并将结果存储在 %propobj 中。<br />
<br />
　在上面的指令中，如果参数中有 %res ，并且 res 不是 0 、则结果也会存储在 %res 中。<br />
</dd>

<dt><a id="id551" name="id551" class="targanchor"><dfn>bnot</dfn></a><br />
(bitwise not)</dt>
<dd>格式: <code class="inlinecode">bnot %reg</code><br />
<br />
　将 %reg 每一位的真假反转，并将其重新存储在 %reg。</dd>

<dt><a id="id552" name="id552" class="targanchor"><dfn>asc</dfn></a><br />
(make ascii string)</dt>
<dd>格式: <code class="inlinecode">asc %reg</code><br />
<br />
　根据 %reg 表示的数字创建一个对应的字符，并将其再次存储在 %reg 中。</dd>

<dt><a id="id553" name="id553" class="targanchor"><dfn>chr</dfn></a><br />
(cheracter code)</dt>
<dd>格式: <code class="inlinecode">chr %reg</code><br />
<br />
　将 %reg 表示的字符串中第一个字符的字符编码存储在 %reg 中。</dd>

<dt><a id="id554" name="id554" class="targanchor"><dfn>num</dfn></a><br />
(number)</dt>
<dd>格式: <code class="inlinecode">num %reg</code><br />
<br />
　将 %reg 表示的寄存器转换为数字。</dd>

<dt><a id="id555" name="id555" class="targanchor"><dfn>chs</dfn></a><br />
(change sign)</dt>
<dd>格式: <code class="inlinecode">chs %reg</code><br />
<br />
　将 %reg 表示的寄存器数值的正负颠倒。</dd>

<dt><a id="id556" name="id556" class="targanchor"><dfn>inv</dfn></a><br />
(invalidate)</dt>
<dd>格式: <code class="inlinecode">inv %reg</code><br />
<br />
　禁用 %reg 表示的对象。</dd>

<dt><a id="id557" name="id557" class="targanchor"><dfn>chkinv</dfn></a><br />
(invalidate)</dt>
<dd>格式: <code class="inlinecode">chkinv %reg</code><br />
<br />
　如果 %reg 表示的对象未禁用，则将 %reg 设置为真，否则设置为假。</dd>

<dt><a id="id558" name="id558" class="targanchor"><dfn>int</dfn></a><br />
(convert to integer)</dt>
<dd>格式: <code class="inlinecode">int %reg</code><br />
<br />
　将 %reg 表示的寄存器转换为整数。</dd>

<dt><a id="id559" name="id559" class="targanchor"><dfn>real</dfn></a><br />
(convert to real)</dt>
<dd>格式: <code class="inlinecode">real %reg</code><br />
<br />
　将 %reg 表示的寄存器转换为实数。</dd>

<dt><a id="id560" name="id560" class="targanchor"><dfn>string</dfn></a><br />
(convert to string)</dt>
<dd>格式: <code class="inlinecode">string %reg</code><br />
<br />
　将 %reg 表示的寄存器转换为字符串。</dd>

<dt><a id="id561" name="id561" class="targanchor"><dfn>octet</dfn></a><br />
(convert to octet)</dt>
<dd>格式: <code class="inlinecode">octet %reg</code><br />
<br />
　将 %reg 表示的寄存器转换为字节串。</dd>

<dt><a id="id562" name="id562" class="targanchor"><dfn>typeof</dfn></a>, <a id="id563" name="id563" class="targanchor"><dfn>typeofd</dfn></a>, <a id="id564" name="id564" class="targanchor"><dfn>typeofi</dfn></a><br />
(check type)</dt>
<dd>格式: <code class="inlinecode">typeof %reg</code><br />
格式: <code class="inlinecode">typeofd %obj.*name</code><br />
格式: <code class="inlinecode">typeofi %obj.%name</code><br />
<br />
　检查 %reg 或 %obj.*name 或 %obj.%name 的数据类型、并将表示该类型的字符串再次存储在 %reg 或 %obj.*name 或 %obj.%name 中。</dd>

<dt><a id="id565" name="id565" class="targanchor"><dfn>eval</dfn></a><br />
(evaluate expression)</dt>
<dd>格式: <code class="inlinecode">eval %reg</code><br />
<br />
　将 %reg 表示的字符串作为表达式执行，并将结果再次存储在 %reg 中。</dd>

<dt><a id="id566" name="id566" class="targanchor"><dfn>eexp</dfn></a><br />
(execute expression)</dt>
<dd>格式: <code class="inlinecode">eexp %reg</code><br />
<br />
　将 %reg 表示的字符串作为表达式运行，并丢弃结果。</dd>

<dt><a id="id567" name="id567" class="targanchor"><dfn>chkins</dfn></a><br />
(check instance)</dt>
<dd>格式: <code class="inlinecode">chkins %reg, %classname</code><br />
<br />
　如果以 %reg 表示的对象是以 %classname 表示的类名的类实例，则将真值存储在 %reg 中，否则将存储假值。</dd>

<dt><a id="id568" name="id568" class="targanchor"><dfn>call</dfn></a>, <a id="id569" name="id569" class="targanchor"><dfn>calld</dfn></a>, <a id="id570" name="id570" class="targanchor"><dfn>calli</dfn></a><br />
(function call)</dt>
<dd>格式: <code class="inlinecode">call %dest, %func(%arg1, %arg2, %arg3, ...)</code><br />
格式: <code class="inlinecode">calld %dest, %obj.*name(%arg1, %arg2, %arg3, ...)</code><br />
格式: <code class="inlinecode">calli %dest, %obj.%name(%arg1, %arg2, %arg3, ...)</code><br />
<br />
　使用 %func 或 %obj.*name 或 %obj.%name 表示的函数对象调用 %arg1, %arg2, %arg3... 等参数，并将其结果存储在 %dest 中。如果 %dest 为 %0 ，则结果将被丢弃 (不存储在 %0 中 )。</dd>

<dt><a id="id571" name="id571" class="targanchor"><dfn>new</dfn></a><br />
(create new)</dt>
<dd>格式: <code class="inlinecode">new %dest, %func(%arg1, %arg2, %arg3, ...)</code><br />
<br />
　使用参数 %arg1, %arg2, %arg3 ... 来构建用 %func 表示的类对象，并将结果存储在 %dest 中。</dd>

<dt><a id="id572" name="id572" class="targanchor"><dfn>gpd</dfn></a>, <a id="id573" name="id573" class="targanchor"><dfn>gpds</dfn></a><br />
(get property direct)</dt>
<dd>格式: <code class="inlinecode">gpd %dest, %obj.*name</code><br />
格式: <code class="inlinecode">gpds %dest, %obj.*name</code><br />
<br />
　将以 %obj 表示的对象引用以 *name 表示的直接成员的值复制到 %dest 中。<br />
　gpd 调用属性控制器，gpds 则不调用属性控制器，而是获取属性对象本身。</dd>

<dt><a id="id574" name="id574" class="targanchor"><dfn>gpi</dfn></a>, <a id="id575" name="id575" class="targanchor"><dfn>gpis</dfn></a><br />
(get property indirect)</dt>
<dd>格式: <code class="inlinecode">gpi %dest, %obj.%name</code><br />
格式: <code class="inlinecode">gpis %dest, %obj.%name</code><br />
<br />
　将以 %obj 表示的对象引用以 %name 表示的间接成员的值复制到 %dest 中。<br />
　gpi 调用属性控制器，而 gpis 并不调用属性控制器，而是获取属性对象本身。</dd>

<dt><a id="id576" name="id576" class="targanchor"><dfn>spd</dfn></a>, <a id="id577" name="id577" class="targanchor"><dfn>spde</dfn></a>, <a id="id578" name="id578" class="targanchor"><dfn>spdeh</dfn></a>, <a id="id579" name="id579" class="targanchor"><dfn>spds</dfn></a><br />
(set property direct)</dt>
<dd>格式: <code class="inlinecode">spd %obj.*name, %src</code><br />
格式: <code class="inlinecode">spde %obj.*name, %src</code><br />
格式: <code class="inlinecode">spdeh %obj.*name, %src</code><br />
格式: <code class="inlinecode">spds %obj.*name, %src</code><br />
译者注：这里的格式补充了%src的位置。<br />
<br />
　将 %src 的值赋值给以 %obj 表示的对象的直接成员 *name。<br />
　spd 执行正常读取访问，但如果成员不存在则会发生异常。<br />
　spde 在该成员不存在时创建一个新成员。<br />
　spdeh 将成员设置为隐藏成员。在当前版本中没有任何意义。<br />
　spds 不会调用属性控制器，而是替换属性对象本身。<br />
译者注：spds指令通常在用 <code class="inlinecode">&amp;</code> 运算符操作属性对象时用到。</dd>

<dt><a id="id580" name="id580" class="targanchor"><dfn>spi</dfn></a>, <a id="id581" name="id581" class="targanchor"><dfn>spie</dfn></a>, <a id="id582" name="id582" class="targanchor"><dfn>spis</dfn></a><br />
(set property indirect)</dt>
<dd>格式: <code class="inlinecode">spi %obj.%name, %src</code><br />
格式: <code class="inlinecode">spie %obj.%name, %src</code><br />
格式: <code class="inlinecode">spis %obj.%name, %src</code><br />
译者注：这里的格式补充了%src的位置。<br />
<br />
　将 %src 的值赋值给以 %obj 表示的对象的以 %name 表示的间接成员。<br />
　spi 执行正常读取访问，但如果成员不存在则会发生异常。<br />
　spie 在该成员不存在时创建一个新成员。<br />
　spis 不会调用属性控制器，而是替换属性对象本身。</dd>

<dt><a id="id583" name="id583" class="targanchor"><dfn>getp</dfn></a></dt>
<dd>格式: <code class="inlinecode">getp %reg, %propobj</code><br />
<br />
　运行由 %propobj 表示的属性对象的 getter 方法，以获取属性的值，并将其赋值给 %reg。相当于执行单目运算符 '*' 的行为。<br />
</dd>
<dt><a id="id584" name="id584" class="targanchor"><dfn>setp</dfn></a></dt>
<dd>格式: <code class="inlinecode">setp %propobj, %reg</code><br />
<br />
　运行由 %propobj 表示的属性对象的 setter 方法，以设置 %reg 的值。相当于执行单目运算符 '*' 的行为。<br />
</dd>
<dt><a id="id585" name="id585" class="targanchor"><dfn>deld</dfn></a>, <a id="id586" name="id586" class="targanchor"><dfn>deli</dfn></a><br />
(delete member)</dt>
<dd>格式: <code class="inlinecode">deld %reg, %obj.*name</code><br />
格式: <code class="inlinecode">deli %reg, %obj.%name</code><br />
<br />
　删除以 %obj 表示对象的以 *name 或 %name 表示的成员。<br />
　将删除成功的真假结果存储在 %reg 中，但如果 %reg 为 %0 ，则丢弃结果。</dd>

<dt><a id="id587" name="id587" class="targanchor"><dfn>srv</dfn></a><br />
(set result value)</dt>
<dd>格式: <code class="inlinecode">srv %reg</code><br />
<br />
　将 %reg 的值作为函数的返回值 ( 即函数返回值为 %reg 所表示的值 )。</dd>

<dt><a id="id588" name="id588" class="targanchor"><dfn>ret</dfn></a><br />
(return)</dt>
<dd>格式: <code class="inlinecode">ret</code><br />
<br />
　返回到调用位置。</dd>

<dt><a id="id589" name="id589" class="targanchor"><dfn>entry</dfn></a><br />
(enter try block)</dt>
<dd>格式: <code class="inlinecode">entry ip, %reg</code><br />
<br />
　进入异常保护块。如果出现异常，将跳转到 ip ，并将异常对象设置为 %reg。</dd>

<dt><a id="id590" name="id590" class="targanchor"><dfn>extry</dfn></a><br />
(exit from try block)</dt>
<dd>格式: <code class="inlinecode">extry</code><br />
<br />
　跳出异常保护块。</dd>

<dt><a id="id591" name="id591" class="targanchor"><dfn>throw</dfn></a><br />
(throw exception object)</dt>
<dd>格式: <code class="inlinecode">throw %reg</code><br />
<br />
　抛出以 %reg 所表示的对象，作为异常对象。</dd>

<dt><a id="id592" name="id592" class="targanchor"><dfn>chgthis</dfn></a><br />
(change this)</dt>
<dd>格式: <code class="inlinecode">chgthis %dest, %src</code><br />
<br />
　将以 %dest 表示的对象的闭包部分更改为以 %src 表示的对象。</dd>

<dt><a id="id593" name="id593" class="targanchor"><dfn>global</dfn></a><br />
(get global object)</dt>
<dd>格式: <code class="inlinecode">global %dest</code><br />
<br />
　将全局对象存储在 %dest 中。</dd>

<dt><a id="id594" name="id594" class="targanchor"><dfn>addci</dfn></a><br />
(add class instance information)</dt>
<dd>格式: <code class="inlinecode">addci %dest, %info</code><br />
<br />
　向 %dest 表示的对象的类实例信息添加 %info。</dd>
　译者注：简单来说就是常用于给定义的类一个命名
<dt><a id="id595" name="id595" class="targanchor"><dfn>regmember</dfn></a><br />
(register members)</dt>
<dd>格式: <code class="inlinecode">regmember</code><br />
<br />
　将类成员注册到 &quot;this&quot; 中。在其内部使用。</dd>


<dt><a id="id596" name="id596" class="targanchor"><dfn>debugger</dfn></a><br />
(call debugger)</dt>
<dd>格式: <code class="inlinecode">debugger</code><br />
<br />
　停止运行并调用调试器。当前版本只实现了调用本地调试器、而不是TJS2调试器。</dd>
</dl></div></div>
	<script type="text/javascript" charset="UTF-8" src="documentid.js" ></script>
	<script type="text/javascript" charset="UTF-8" src="postcontent.js" ></script>
</body>
</html>
